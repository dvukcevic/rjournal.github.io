# Generated by `rjournal_pdf_article()` using `knitr::purl()`: do not edit by hand
# Please edit murrell-definitions-2023.Rmd to modify this file

## ----setup, include=FALSE-----------------------------------------------------
knitr::opts_chunk$set(warning = FALSE, message = FALSE, 
                      dev = "png", dpi = 100, dev.args = list(type = "cairo"))
library(grid)


## ----echo=FALSE---------------------------------------------------------------
percent <- c(51, 48, 46, 41, 29, 25, 34, 18, 18)

group <- c("medical school applicants",
           "medical school graduates",
           "residents",
           "faculty",
           "division chiefs",
           "full professors",
           "senior associate deans",
           "department chairs",
           "deans")

o <- order(percent, decreasing=TRUE)

amount <- percent[o]
label <- gsub(" ", "\n", group[o])

diam <- sqrt(amount)
rad <- diam/2
circleX <- cumsum(diam) - diam/2
circleY <- rad

numCircles <- length(percent)
circleWidths <- diam
circleRadii <- rad
w <- sum(diam)
h <- 2*max(diam)
purple <- colorspace::darken("purple", .5)


## ----gridsetup, echo=FALSE----------------------------------------------------
library(grid)
grad <- linearGradient(rgb(0, 0, 0, c(.5, .1)),
                       y1=.5, y2=.5)
gradientCircle <- function(y, r) {
    circle1 <- circleGrob(y=unit(y, "native"),
                          r=unit(r, "native") + unit(1.5, "mm"), 
                          gp=gpar(col=NA, fill=grad))
    circle2 <- circleGrob(y=unit(y, "native"),
                          r=unit(r, "native") - unit(1.5, "mm"), 
                          gp=gpar(fill="white"))
    grid.group(circle2, "dest.out", circle1)
}

## ----grid, echo=FALSE, eval=FALSE---------------------------------------------
#> grid.rect(gp=gpar(col=NA, fill="grey95"))
#> pushViewport(viewport(width=unit(1, "npc") - unit(3, "mm"),
#>                       y=unit(1.5, "mm"), just="bottom",
#>                       layout=grid.layout(1, numCircles,
#>                                          widths=circleWidths, heights=h,
#>                                          respect=TRUE)))
#> for (i in 1:numCircles) {
#>     pushViewport(viewport(layout.pos.col=i, yscale=c(0, h)))
#>     gradientCircle(circleRadii[i], circleRadii[i])
#>     amountGrob <- textGrob(paste0(amount[i], "%"),
#>                            unit(.5, "npc"),
#>                            unit(circleRadii[i], "native"),
#>                            gp=gpar(col=purple,
#>                                    fontface="bold",
#>                                    cex=1 + amount[i]/max(amount)))
#>     labelGrob <- textGrob(toupper(label[i]),
#>                           .5, .7,
#>                           just="bottom",
#>                           gp=gpar(fontface="bold", cex=.7, lineheight=1))
#>     grid.draw(amountGrob)
#>     grid.draw(labelGrob)
#>     grid.segments(.5,
#>                   grobY(amountGrob, 90) + unit(2, "mm"),
#>                   .5,
#>                   grobY(labelGrob, 270) - unit(2, "mm"),
#>                   gp=gpar(col=purple, lwd=2))
#>     popViewport()
#> }


## ----diagram, echo=FALSE, fig.width=11, fig.height=3, out.width='100%', fig.cap="A diagram with a semi-transparent linear gradient on each circle border.", fig.alt="A diagram with a horizontal row of circles that slowly decrease in size.  There is a semi-transparent linear gradient on each circle border.", fig.pos="h"----
grid.rect(gp=gpar(col=NA, fill="grey95"))
pushViewport(viewport(width=unit(1, "npc") - unit(3, "mm"),
                      y=unit(1.5, "mm"), just="bottom",
                      layout=grid.layout(1, numCircles,
                                         widths=circleWidths, heights=h, 
                                         respect=TRUE)))
for (i in 1:numCircles) {
    pushViewport(viewport(layout.pos.col=i, yscale=c(0, h)))
    gradientCircle(circleRadii[i], circleRadii[i])
    amountGrob <- textGrob(paste0(amount[i], "%"),
                           unit(.5, "npc"), 
                           unit(circleRadii[i], "native"),
                           gp=gpar(col=purple,
                                   fontface="bold",
                                   cex=1 + amount[i]/max(amount)))
    labelGrob <- textGrob(toupper(label[i]),
                          .5, .7,
                          just="bottom",
                          gp=gpar(fontface="bold", cex=.7, lineheight=1))
    grid.draw(amountGrob)
    grid.draw(labelGrob)
    grid.segments(.5,
                  grobY(amountGrob, 90) + unit(2, "mm"),
                  .5,
                  grobY(labelGrob, 270) - unit(2, "mm"),
                  gp=gpar(col=purple, lwd=2))
    popViewport()
}


## -----------------------------------------------------------------------------
library(grid)
linearbg <- linearGradient(grey(c(.8, .99)), 
                           x1=0, x2=1, y1=.5, y2=.5)


## ----ggplot2bg, fig.width=6, fig.height=4, out.width='100%', fig.cap='A ggplot2 plot with a subtle linear gradient background.', fig.alt='A scatter plot with a subtle linear gradient background.', fig.pos="h"----
library(ggplot2)
ggplot(mtcars) +
    geom_point(aes(disp, mpg)) +
    theme(plot.background=element_rect(fill=linearbg, colour=NA),
          plot.margin=unit(c(1, 1, .25, .25), "cm"),
          panel.background=element_rect(fill=NA, colour="black"),
          panel.grid=element_blank())


## ----bgRect, echo=FALSE-------------------------------------------------------
bgRect <- rectGrob(x=unit(.5, "npc") + unit(c(0, -.1), "in"),
                   y=unit(.5, "npc") + unit(c(0, -.1), "in"),
                   just=c("left", "bottom"),
                   width=.1, height=.1, default.units="in",
                   gp=gpar(col="gray80", fill="gray80"))

## ----bg, echo=FALSE-----------------------------------------------------------
bg <- pattern(bgRect,
              width=unit(.2, "in"),
              height=unit(.2, "in"),
              extend="repeat")

## ----frame, echo=FALSE, eval=FALSE--------------------------------------------
#> grid.rect(gp=gpar(col=NA, fill=bg))


## ----blues--------------------------------------------------------------------
blues <- rgb(0, 0, 1, alpha=c(.8, .1))
blues


## ----gradient-----------------------------------------------------------------
gradient <- linearGradient(blues, x1=0, x2=1, y1=.5, y2=.5)


## ----circlefillsolid, eval=FALSE----------------------------------------------
#> grid.circle(r=.3, gp=gpar(col=NA, fill="blue"))

## ----echo=FALSE, fig.width=1, fig.height=1------------------------------------
grid.rect(gp=gpar(col=NA, fill=bg))
grid.circle(r=.3, gp=gpar(col=NA, fill="blue"))


## ----circlefillgrad, eval=FALSE-----------------------------------------------
#> grid.circle(r=.3, gp=gpar(col=NA, fill=gradient))

## ----echo=FALSE, fig.width=1, fig.height=1------------------------------------
grid.rect(gp=gpar(col=NA, fill=bg))
grid.circle(r=.3, gp=gpar(col=NA, fill=gradient))


## -----------------------------------------------------------------------------
radial <- radialGradient(blues, r1=.5, r2=0)


## ----circlefillrad, eval=FALSE------------------------------------------------
#> grid.circle(r=.3, gp=gpar(col=NA, fill=radial))

## ----echo=FALSE, fig.width=1, fig.height=1------------------------------------
grid.rect(gp=gpar(col=NA, fill=bg))
grid.circle(r=.3, gp=gpar(col=NA, fill=radial))


## ----rectfillrad, eval=FALSE--------------------------------------------------
#> grid.rect(width=.6, height=.6, gp=gpar(col=NA, fill=radial))

## ----echo=FALSE, fig.width=1, fig.height=1------------------------------------
grid.rect(gp=gpar(col=NA, fill=bg))
grid.rect(width=.6, height=.6, gp=gpar(col=NA, fill=radial))


## ----eval=FALSE---------------------------------------------------------------
#> bgRect <- rectGrob(x=unit(.5, "npc") + unit(c(0, -.1), "in"),
#>                    y=unit(.5, "npc") + unit(c(0, -.1), "in"),
#>                    just=c("left", "bottom"),
#>                    width=.1, height=.1, default.units="in",
#>                    gp=gpar(col="gray80", fill="gray80"))

## ----echo=FALSE, fig.width=1, fig.height=1------------------------------------
grid.draw(bgRect)


## ----eval=FALSE---------------------------------------------------------------
#> bg <- pattern(bgRect,
#>               width=unit(.2, "in"),
#>               height=unit(.2, "in"),
#>               extend="repeat")

## ----echo=FALSE, fig.width=1, fig.height=1------------------------------------
grid.draw(bgRect)
grid.rect(width=unit(.2, "in"), height=unit(.2, "in"), 
          gp=gpar(col="red", lwd=.5, fill=NA))


## ----fig.width=1, fig.height=1------------------------------------------------
grid.rect(gp=gpar(fill=bg))  


## ----bgcircle, eval=FALSE-----------------------------------------------------
#> grid.circle(gp=gpar(fill=bg))

## ----echo=FALSE, fig.width=1, fig.height=1------------------------------------
pushViewport(viewport(width=.99, height=.99, gp=gpar(lwd=.5)))
grid.circle(gp=gpar(fill=bg))  


## ----ggplot2clip, fig.width=6, fig.height=4, out.width='100%', fig.cap='A ggplot2 plot with the left-most and right-most data symbols clipped to the edges of the plot region.', fig.alt='A scatter plot with the left-most and right-most data symbols clipped to the edges of the plot region.', fig.pos="h"----
ggplot(mtcars) +
    geom_point(aes(disp, mpg), size=3) +
    scale_x_continuous(expand=c(0, 0)) +
    theme(plot.margin=unit(c(1, 1, .25, .25), "cm"),
          panel.background=element_rect(fill=NA, colour="black"),
          panel.grid=element_blank())


## ----circle, eval=FALSE-------------------------------------------------------
#> gradient2 <- linearGradient(blues, x1=0, x2=1, y1=.5, y2=.5,
#>                             group=FALSE)
#> circles <- circleGrob(x=0:1, r=.5, gp=gpar(col=NA, fill="blue"))
#> grid.draw(circles)

## ----echo=FALSE, fig.width=1, fig.height=1------------------------------------
grid.rect(gp=gpar(col=NA, fill=bg))
gradient2 <- linearGradient(blues, x1=0, x2=1, y1=.5, y2=.5,
                            group=FALSE)
circles <- circleGrob(x=0:1, r=.5, gp=gpar(col=NA, fill="blue"))
grid.draw(circles)


## ----viewport, eval=FALSE-----------------------------------------------------
#> pushViewport(viewport(width=.5, height=.5))
#> grid.draw(circles)
#> popViewport()

## ----echo=FALSE, fig.width=1, fig.height=1------------------------------------
grid.rect(gp=gpar(col=NA, fill=bg))
pushViewport(viewport(width=.5, height=.5))
grid.draw(circles)
popViewport()
pushViewport(viewport(width=.5, height=.5))
grid.rect(gp=gpar(col="red", fill=NA))


## ----vpclip, eval=FALSE-------------------------------------------------------
#> pushViewport(viewport(width=.5, height=.5, clip=TRUE))
#> grid.draw(circles)
#> popViewport()

## ----echo=FALSE, fig.width=1, fig.height=1------------------------------------
grid.rect(gp=gpar(col=NA, fill=bg))
pushViewport(viewport(width=.5, height=.5, clip=TRUE))
grid.draw(circles)
popViewport()
pushViewport(viewport(width=.5, height=.5))
grid.rect(gp=gpar(col="purple", fill=NA))


## ----diamond------------------------------------------------------------------
diamondPath <- polygonGrob(c(0, .5, 1, .5), c(.5, 1, .5, 0))

## ----echo=FALSE, fig.width=1, fig.height=1------------------------------------
grid.rect(gp=gpar(col=NA, fill=bg))
pushViewport(viewport(gp=gpar(fill=NA)))
grid.draw(diamondPath)


## ----vpclippath, eval=FALSE---------------------------------------------------
#> pushViewport(viewport(width=.5, height=.5, clip=diamondPath))
#> grid.draw(circles)
#> popViewport()

## ----echo=FALSE, fig.width=1, fig.height=1------------------------------------
grid.rect(gp=gpar(col=NA, fill=bg))
pushViewport(viewport(width=.5, height=.5, clip=diamondPath))
grid.draw(circles)
popViewport()
pushViewport(viewport(width=.5, height=.5))
grid.rect(gp=gpar(col="red", fill=NA))
grid.draw(editGrob(diamondPath, gp=gpar(col="purple", fill=NA)))


## ----diamondmask--------------------------------------------------------------
diamondMask <- polygonGrob(c(0, .5, 1, .5), c(.5, 1, .5, 0),
                           gp=gpar(fill="black"))

## ----echo=FALSE, fig.width=1, fig.height=1------------------------------------
grid.rect(gp=gpar(col=NA, fill=bg))
grid.draw(diamondMask)


## ----vpmask, eval=FALSE-------------------------------------------------------
#> pushViewport(viewport(width=.5, height=.5, mask=diamondMask))
#> grid.draw(circles)
#> popViewport()

## ----echo=FALSE, fig.width=1, fig.height=1------------------------------------
grid.rect(gp=gpar(col=NA, fill=bg))
pushViewport(viewport(width=.5, height=.5, mask=diamondMask))
grid.draw(circles)
popViewport()
pushViewport(viewport(width=.5, height=.5))
grid.rect(gp=gpar(col="red", fill=NA))


## ----alphamask----------------------------------------------------------------
alphaMask <- grobTree(polygonGrob(c(0, .5, 1, .5), c(.5, 1, .5, 0),
                                  gp=gpar(fill=rgb(0,0,0,.5))),
                      pathGrob(c(0, 0, 1, 1, 0, .5, 1, .5),
                               c(0, 1, 1, 0, .5, 1, .5, 0),
                               id=rep(1:2, each=4),
                               rule="evenodd",
                               gp=gpar(fill="black")))

## ----echo=FALSE, fig.width=1, fig.height=1------------------------------------
grid.rect(gp=gpar(col=NA, fill=bg))
grid.draw(alphaMask)


## ----vpalphamask, eval=FALSE--------------------------------------------------
#> pushViewport(viewport(width=.5, height=.5, mask=alphaMask))
#> grid.draw(circles)
#> popViewport()

## ----echo=FALSE, fig.width=1, fig.height=1------------------------------------
grid.rect(gp=gpar(col=NA, fill=bg))
pushViewport(viewport(width=.5, height=.5, mask=alphaMask))
grid.draw(circles)
popViewport()
pushViewport(viewport(width=.5, height=.5))
grid.rect(gp=gpar(col="red", fill=NA))


## ----corners, eval=FALSE------------------------------------------------------
#> grid.path(c(0, 0, 1, 1, 0, .5, 1, .5),
#>           c(0, 1, 1, 0, .5, 1, .5, 0),
#>           id=rep(1:2, each=4),
#>           rule="evenodd",
#>           gp=gpar(fill="black"))

## ----echo=FALSE, fig.width=1, fig.height=1------------------------------------
grid.rect(gp=gpar(col=NA, fill=bg))
grid.path(c(0, 0, 1, 1, 0, .5, 1, .5),
          c(0, 1, 1, 0, .5, 1, .5, 0),
          id=rep(1:2, each=4),
          rule="evenodd",
          gp=gpar(fill="black"))


## ----fillStroke, eval=FALSE---------------------------------------------------
#> grid.fillStroke(grobTree(rectGrob(), diamondPath),
#>                 rule="evenodd",
#>                 gp=gpar(fill="black"))

## ----echo=FALSE, fig.width=1, fig.height=1------------------------------------
grid.rect(gp=gpar(col=NA, fill=bg))
grid.fillStroke(grobTree(rectGrob(), diamondPath),
                rule="evenodd",
                gp=gpar(fill="black"))


## ----fillStroke2, eval=FALSE--------------------------------------------------
#> grid.fillStroke(grobTree(rectGrob(), circleGrob()),
#>                 rule="evenodd",
#>                 gp=gpar(fill="black"))

## ----echo=FALSE, fig.width=1, fig.height=1------------------------------------
grid.rect(gp=gpar(col=NA, fill=bg))
grid.fillStroke(grobTree(rectGrob(), circleGrob()),
                rule="evenodd",
                gp=gpar(fill="black"))


## ----stroke, eval=FALSE-------------------------------------------------------
#> grid.stroke(textGrob("path", gp=gpar(cex=2.5)))

## ----echo=FALSE, fig.width=1, fig.height=1------------------------------------
grid.rect(gp=gpar(col=NA, fill=bg))
grid.stroke(textGrob("path", gp=gpar(cex=2.5)))


## ----circle1------------------------------------------------------------------
circle1 <- circleGrob(r=.35, gp=gpar(col=NA, fill="blue"))

## ----echo=FALSE, fig.width=1, fig.height=1------------------------------------
grid.rect(gp=gpar(col=NA, fill=bg))
grid.draw(circle1)

## ----circle2------------------------------------------------------------------
circle2 <- circleGrob(r=.25, gp=gpar(col=NA, fill="black"))

## ----echo=FALSE, fig.width=1, fig.height=1------------------------------------
grid.rect(gp=gpar(col=NA, fill=bg))
grid.draw(circle2)


## ----opover, eval=FALSE-------------------------------------------------------
#> grid.draw(circle1)
#> grid.draw(circle2)

## ----echo=FALSE, fig.width=1, fig.height=1------------------------------------
grid.rect(gp=gpar(col=NA, fill=bg))
grid.draw(circle1)
grid.draw(circle2)


## ----opdestout, eval=FALSE----------------------------------------------------
#> grid.group(circle2, "dest.out", circle1)

## ----echo=FALSE, fig.width=1, fig.height=1------------------------------------
grid.rect(gp=gpar(col=NA, fill=bg))
grid.group(circle2, "dest.out", circle1)


## ----dst----------------------------------------------------------------------
dst <- circleGrob(r=.35, gp=gpar(col=NA, fill=gradient))

## ----echo=FALSE, fig.width=1, fig.height=1------------------------------------
grid.rect(gp=gpar(col=NA, fill=bg))
grid.draw(dst)


## ----src----------------------------------------------------------------------
src <- circleGrob(r=.25, gp=gpar(col=NA, fill="black"))

## ----echo=FALSE, fig.width=1, fig.height=1------------------------------------
grid.rect(gp=gpar(col=NA, fill=bg))
grid.draw(src)


## ----composite, eval=FALSE----------------------------------------------------
#> grid.group(src, "dest.out", dst)

## ----echo=FALSE, fig.width=1, fig.height=1------------------------------------
grid.rect(gp=gpar(col=NA, fill=bg))
grid.group(src, "dest.out", dst)


## ----echo=FALSE---------------------------------------------------------------
f <- function(x) {
    mean <- mean(x)
    sd <- sd(x)
    c(mean=mean, sd=sd)
}
TGsummary <- do.call(data.frame, 
                     aggregate(ToothGrowth["len"], 
                               ToothGrowth[c("supp", "dose")], f))


## ----ggdist, fig.width=6, fig.height=4, out.width='100%', fig.cap="A ggdist plot that uses linear gradients to represent variability within groups.", fig.alt="A plot with two panels and three groups in each panel.  Each group is represented by a dot at the centre of a vertical line.  There is also a vertical linear gradient for each vertical line that fades from darker at the middle to lighter at the ends of the line.", fig.pos="h"----
library(ggdist)
library(distributional)
ggplot(TGsummary) +
    stat_gradientinterval(aes(x=dose, ydist=dist_normal(len.mean, len.sd))) +
    facet_wrap("supp")


## -----------------------------------------------------------------------------
library(gggrid)
outlineLabel <- function(data, coords) {
    text <- textGrob(paste0(data$percent[2], "%"), gp=gpar(cex=3))
    grobTree(strokeGrob(text, gp=gpar(col="white", lwd=10)),
             text)
}


## ----echo=FALSE---------------------------------------------------------------
judges <- data.frame(president=rep(c("Trump", "Obama"), each=100),
                     race=c(rep(c("white", "other"), c(84, 16)),
                            rep(c("white", "other"), c(64, 36))),
                     x=rep(1:10, 10),
                     y=rep(1:10, each=10))
judgeCounts <- as.data.frame(with(judges, table(president, race)))

## ----gggrid, fig.width=4, fig.height=2, fig.cap="Outlined text on a ggplot2 plot produced with the gggrid package and stroked paths.", fig.alt="A plot with two matrices of 100 squares, some of which are filled yellow and the rest grey.  On top of each matrix there is a text annotation that has a thick white outline.", fig.pos="h"----
ggplot(judges) +
    geom_tile(aes(x, y, fill=race), color="white", lwd=.7) +
    grid_panel(outlineLabel, aes(percent=Freq), data=judgeCounts) +
    facet_wrap("president") +
    scale_fill_manual(values=c(white="#F8C216", other="grey80")) +
    theme_void() +
    theme(aspect.ratio=1,
          legend.position="none")


## ----echo=FALSE---------------------------------------------------------------
x <- seq(-10, 10, length=100)
y1 <- x^2
y2 <- x^3


## -----------------------------------------------------------------------------
library(lattice)
key <- list(text=list(expression(y1 == x^2, y2 == x^3)),
                      lines=list(col=2:3, lwd=3),
                      padding.text=3,
                      border=TRUE,
                      x=.5, y=.75, corner=c(.5, .5))


## ----latticesrc, eval=FALSE---------------------------------------------------
#> xyplot(y1 + y2 ~ x, type="l", lwd=3, col=2:3,
#>        panel=function(...) {
#>                  panel.grid(h=-1, v=-1, col="black")
#>                  panel.xyplot(...)
#>        },
#>        key=key)


## ----lattice, echo=FALSE, fig.width=6, fig.height=4, out.width='100%', fig.cap="A plot of two mathematical functions drawn with the lattice package.  The checkerboard pattern is there to show that the plot itself has a transparent background.", fig.alt="A plot of two mathematical functions represented by smooth coloured lines.  There are reference grid lines and a legend that overlaps two of the grid lines.", fig.pos="h"----
grid.rect(gp=gpar(col=NA, fill=bg))
grid.rect(gp=gpar(col=NA, fill=rgb(1,1,1,.5)))
print(
xyplot(y1 + y2 ~ x, type="l", lwd=3, col=2:3,
       panel=function(...) { 
                 panel.grid(h=-1, v=-1, col="black")
                 panel.xyplot(...)
       },
       key=key)
, newpage=FALSE)


## -----------------------------------------------------------------------------
keygrob <- draw.key(key=key, vp=viewport(x=.5, y=.75))


## -----------------------------------------------------------------------------
keyMask <- fillGrob(as.path(grobTree(rectGrob(width=2, height=2),
                                     keygrob),
                            rule="evenodd",
                            gp=gpar(fill="black")))


## ----legendsrc, eval=FALSE----------------------------------------------------
#> xyplot(y1 + y2 ~ x, type="l", lwd=3, col=2:3,
#>        panel=function(...) {
#>                  limits <- current.panel.limits()
#>                  pushViewport(viewport(mask=keyMask,
#>                                        xscale=limits$xlim,
#>                                        yscale=limits$ylim))
#>                  panel.grid(h=-1, v=-1, col="black")
#>                  popViewport()
#>                  panel.xyplot(...)
#>        },
#>        key=key)


## ----legend, echo=FALSE, fig.width=6, fig.height=4, out.width='100%', fig.cap="A lattice plot with a mask used to only draw the grid lines where they do not overlap with the legend. The checkerboard pattern is there to show that the plot itself has a transparent background.", fig.alt="A plot of two mathematical functions with grid lines and a legend, like the previous figure, except that the grid lines are not drawn where they would overlap with the legend.", fig.pos="h"----
grid.rect(gp=gpar(col=NA, fill=bg))
grid.rect(gp=gpar(col=NA, fill=rgb(1,1,1,.5)))
print(
xyplot(y1 + y2 ~ x, type="l", lwd=3, col=2:3,
       panel=function(...) { 
                 limits <- current.panel.limits()
                 pushViewport(viewport(mask=keyMask, 
                                       xscale=limits$xlim, 
                                       yscale=limits$ylim))
                 panel.grid(h=-1, v=-1, col="black")
                 popViewport()
                 panel.xyplot(...)
       },
       key=key)
, newpage=FALSE)


## ----echo=FALSE---------------------------------------------------------------
library(akima)
quakes <- read.csv("quakes-mod.csv")
quakes$long <- ifelse(quakes$LONG < 0, 360 + quakes$LONG, quakes$LONG)
quakes <- quakes[quakes$LAT < 0 & quakes$long < 190, ]
library(MASS)
qd <- kde2d(quakes$long, quakes$LAT, n=100)
contours <- contourLines(qd$x, qd$y, qd$z, nlevels=10)
nContours <- length(contours)
hue <- 240
colours <- hcl(hue, 50, 20 + 60*nContours:1/(nContours+1))
fills <- adjustcolor(colours, 1, .9, .9, .9)


## ----echo=FALSE---------------------------------------------------------------
library(maps)
library(gridGraphics)


## ----basemap, eval=FALSE------------------------------------------------------
#> library(maps)
#> par(mar=rep(2, 4))
#> map("nz")
#> invisible(mapply(function(c, col, fill) {
#>                      polygon(c$x, c$y, default.units="native",
#>                              border=col, col=fill)
#>                  },
#>                  contours, colours, fills))


## ----basemapsetup, fig.keep="none", echo=FALSE--------------------------------
par(mar=rep(2, 4))
outline <- map("nz")
clipPath <- polylineGrob(outline$x, outline$y, default.units="native")


## ----echo, eval=FALSE, echo=FALSE---------------------------------------------
#> library(gridGraphics)
#> grid.echo()


## ----gridmap, eval=FALSE, echo=FALSE------------------------------------------
#> downViewport("graphics-window-1-0A")
#> cvp <- current.viewport()
#> pushViewport(viewport(xscale=cvp$xscale, yscale=cvp$yscale,
#>                       clip=clipPath))
#> invisible(mapply(function(c, col, fill) {
#>                      grid.polygon(c$x, c$y, default.units="native",
#>                                   gp=gpar(col=col, fill=fill))
#>                  },
#>                  contours, colours, fills))
#> grid.draw(clipPath)
#> popViewport()


## ----map, echo=FALSE, fig.keep="last", fig.width=6, fig.height=4, out.width='100%', fig.cap="Left:  A set of contours drawn on top of a map using base graphics;  Right: The same map, converted to grid graphics using the gridGraphics package, with the contours clipped by using the boundary of the map as the clipping path.", fig.alt="Two maps of New Zealand with contour regions overlaid.  On the left, the contour regions extend beyond the map boundaries.  On the right, the contour regions are clipped to the map boundaries.", fig.pos="h"----
pushViewport(viewport(x=0, width=.5, just="left"))
grid.draw(echoGrob(function() {
library(maps)
par(mar=rep(2, 4))
map("nz")
invisible(mapply(function(c, col, fill) {
                     polygon(c$x, c$y, default.units="native", 
                             border=col, col=fill)
                 },
                 contours, colours, fills))
}))
popViewport()
pushViewport(viewport(x=.5, width=.5, just="left"))
grid.draw(echoGrob(function() {
par(mar=rep(2, 4))
outline <- map("nz")
clipPath <- polylineGrob(outline$x, outline$y, default.units="native")
}))
downViewport("graphics-window-1-0A")
cvp <- current.viewport()
pushViewport(viewport(xscale=cvp$xscale, yscale=cvp$yscale,
                      clip=clipPath))                      
invisible(mapply(function(c, col, fill) {
                     grid.polygon(c$x, c$y, default.units="native", 
                                  gp=gpar(col=col, fill=fill))
                 },
                 contours, colours, fills))
grid.draw(clipPath)
popViewport()
popViewport()


## ----eval=FALSE---------------------------------------------------------------
#> par(mar=rep(2, 4))
#> outline <- map("nz")
#> clipPath <- polylineGrob(outline$x, outline$y, default.units="native")
#> library(gridGraphics)
#> grid.echo()
#> downViewport("graphics-window-1-0A")
#> cvp <- current.viewport()
#> pushViewport(viewport(xscale=cvp$xscale, yscale=cvp$yscale,
#>                       clip=clipPath))
#> invisible(mapply(function(c, col, fill) {
#>                      grid.polygon(c$x, c$y, default.units="native",
#>                                   gp=gpar(col=col, fill=fill))
#>                  },
#>                  contours, colours, fills))
#> grid.draw(clipPath)
#> popViewport()


## ----eval=FALSE---------------------------------------------------------------
#> library(grid)
#> grad <- linearGradient(rgb(0, 0, 0, c(.5, .1)),
#>                        y1=.5, y2=.5)
#> gradientCircle <- function(y, r) {
#>     circle1 <- circleGrob(y=unit(y, "native"),
#>                           r=unit(r, "native") + unit(1.5, "mm"),
#>                           gp=gpar(col=NA, fill=grad))
#>     circle2 <- circleGrob(y=unit(y, "native"),
#>                           r=unit(r, "native") - unit(1.5, "mm"),
#>                           gp=gpar(fill="white"))
#>     grid.group(circle2, "dest.out", circle1)
#> }


## ----gridfig, fig.width=11, fig.height=3, out.width='100%', fig.cap="A diagram with a semi-transparent linear gradient on each circle border.  This is a reproduction of the original image from the Introduction.", fig.alt="A reproduction of the original image from the Introduction.", fig.pos="h"----
grid.rect(gp=gpar(col=NA, fill="grey95"))
pushViewport(viewport(width=unit(1, "npc") - unit(3, "mm"),
                      y=unit(1.5, "mm"), just="bottom",
                      layout=grid.layout(1, numCircles,
                                         widths=circleWidths, heights=h, 
                                         respect=TRUE)))
for (i in 1:numCircles) {
    pushViewport(viewport(layout.pos.col=i, yscale=c(0, h)))
    gradientCircle(circleRadii[i], circleRadii[i])
    amountGrob <- textGrob(paste0(amount[i], "%"),
                           unit(.5, "npc"), 
                           unit(circleRadii[i], "native"),
                           gp=gpar(col=purple,
                                   fontface="bold",
                                   cex=1 + amount[i]/max(amount)))
    labelGrob <- textGrob(toupper(label[i]),
                          .5, .7,
                          just="bottom",
                          gp=gpar(fontface="bold", cex=.7, lineheight=1))
    grid.draw(amountGrob)
    grid.draw(labelGrob)
    grid.segments(.5,
                  grobY(amountGrob, 90) + unit(2, "mm"),
                  .5,
                  grobY(labelGrob, 270) - unit(2, "mm"),
                  gp=gpar(col=purple, lwd=2))
    popViewport()
}


## ----bluecircle, eval=FALSE---------------------------------------------------
#> grid.circle(r=.3, gp=gpar(col="blue", fill="blue"))


## ----echo=FALSE, fig.width=1, fig.height=1------------------------------------
grid.rect(gp=gpar(col=NA, fill=bg))
grid.circle(r=.3, gp=gpar(col="blue", fill="blue"))


## ----eval=FALSE---------------------------------------------------------------
#> grid.group(src, "dest.out", dst)

## ----echo=FALSE, fig.width=1, fig.height=1------------------------------------
grid.rect(gp=gpar(col=NA, fill=bg))
grid.group(src, "dest.out", dst)


## ----structure, echo=FALSE, out.width="70%", fig.align="center", fig.cap="The structure of R graphics.  The features described in this paper involved changes to the grid and grDevices packages, plus some of the graphics devices that are provided with R. Some of the features are becoming available via higher-level packages like ggplot2 and some of the features are supported in external graphics devices like those provided by the ragg package.", fig.alt="A node-and-edge graph: the ggplot2 node and the lattice node are connected to the grid node;  the maps node is connected to the graphics node;  the grid node and the graphics node are connected to the grDevices node;  the grDevices node is connected to the pdf node, the png node, and the ragg node."----
knitr::include_graphics("figures/rgraphics.png")

