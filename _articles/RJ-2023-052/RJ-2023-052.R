# Generated by `rjournal_pdf_article()` using `knitr::purl()`: do not edit by hand
# Please edit RJ-2023-052.Rmd to modify this file

## ----setup, include=FALSE-----------------------------------------------------
knitr::opts_chunk$set(
  echo = FALSE,
  warning = FALSE,
  message = FALSE
)
library(plotly)
library(ggplot2)
library(palmerpenguins)
library(tidyverse)
library(detourr)
library(kableExtra)

# Okabe-Ito for colourblind-friendliness
pal <- unname(palette.colors())[-1]

options(
  knitr.graphics.auto_pdf = TRUE,
  tibble.print_min = 5,
  ggplot2.discrete.fill = pal,
  ggplot2.discrete.colour = pal
)


## ----child="01-introduction.Rmd"----------------------------------------------




## ----child="02-background.Rmd"------------------------------------------------




## ----child="03-software-design-implementation.Rmd"----------------------------

## ----echo=FALSE---------------------------------------------------------------
# remotes::install_github('casperhart/detourr@v0.1.0')

library(detourr)
data(pdfsense, package = "liminal")

pcs <- pdfsense |>
    dplyr::select(X1:X56) |>
    prcomp()

pcs <- as_tibble(pcs$x) |>
    dplyr::select(PC1:PC6)

pdf_df <- pdfsense |>
    dplyr::select(-(X1:X56)) |>
    mutate(Type = as.character(Type)) |>
    bind_cols(pcs)


## ----echo=TRUE----------------------------------------------------------------
p <- detour(pdf_df, tour_aes(
    projection = starts_with("PC"),
    colour = Type,
    label = ID
))


## ----echo=TRUE----------------------------------------------------------------
p <- p |> tour_path(grand_tour(3))
p


## ----echo=TRUE, eval=FALSE----------------------------------------------------
#> p |> show_scatter(axes = FALSE)


## ----scatter-display-static, fig.cap = "Initial frame of the scatterplot display generated by the `show\\_scatter` display function. Controls are on the left, and an interactive timeline is on the bottom of the plot.", eval=knitr::is_latex_output(), out.width="\\textwidth"----
knitr::include_graphics("figures/implementation/pdfsense_scatter_3d.png")


## ----scatter-display-interactive, fig.cap = "Interactive scatterplot display generated by the `show_scatter` display function. Controls are on the left, and an interactive timeline is on the bottom of the plot.", eval=knitr::is_html_output()----
#> p |> show_scatter(axes = FALSE, size = 0.5)


## ----echo=TRUE, eval=FALSE----------------------------------------------------
#> detour(pdf_df, tour_aes(
#>     projection = starts_with("PC"),
#>     colour = Type,
#>     label = ID
#> )) |>
#>     tour_path(grand_tour(3)) |>
#>     show_scatter()


## ----hover-tooltip, echo = FALSE, out.width="50%", fig.ncol=2, fig.show="hold", fig.cap="(Left) Tooltip showing data from the 6 columns specified in the `label` aesthetic. Note that both the column names and values are present in the tooltip. (Right) The `ID` column is provided as-is to the label aesthetic via the `I()` function."----
knitr::include_graphics(c(
    "figures/implementation/hover_tooltip.png",
    "figures/implementation/hover_tooltip_asis.png"
))


## ----echo=FALSE---------------------------------------------------------------
controls_df <- tibble(
    Control = c("Orbit", "Pan", "Box Selection", "Brush", "Colour Selector"),
    Icon = paste0(
        "figures/implementation/",
        c(
            "orbit_control_button.png",
            "pan_button.png",
            "select_button.png",
            "brush.png",
            "colour_selector.png"
        )
    ),
    Description = c(
        "When the `show_scatter()` widget is generated, orbit controls will be enabled by default. This allows click and drag to rotate the visual, and scrolling/pinching to zoom. Note that orbit controls for the 2D variant work best if dragging from left to right, not up and down. Also note that the icon for the currently selected control will be highlighted blue; otherwise it will be black.",
        "The pan control also allows scrolling to zoom, and click and drag to pan.",
        "The selection control allows for transitory box selection by brushing. Holding the `shift` key will allow for persistent selection, and points outside of the selection will be indicated by increased transparency. There is currently a limitation where only visible points can be selected. If a point is completely obscured by other points, it will not be selected.",
        "The brush button will apply the current colour to the selected points.",
        "The colour selector will look slightly different depending on the browser being used. When the colour selection is changed, the selected points will be updated immediately."
    )
)


## ----html-controls, eval=knitr::is_html_output()------------------------------
#> html_table <- controls_df |>
#>     mutate(Icon = paste0("![](", Icon, ")"))
#> knitr::kable(html_table,
#>     format = "html",
#>     caption = "An overview of the interactive controls available in the detourr displays"
#> )


## ----pdf-controls, eval=knitr::is_latex_output()------------------------------
pdf_table <- controls_df |>
    mutate(
        Icon = paste0(
            "\\raisebox{-\\totalheight}{\\includegraphics[width=0.2\\textwidth]{", Icon, "}}"
        ),
        Description = gsub("\\_", "\\\\_", Description)
    )

knitr::kable(pdf_table,
    format = "latex", caption = "An overview of the interactive controls available in the \\pkg{detourr} displays",
    escape = FALSE,
    booktabs = TRUE
) |>
    kable_styling() |>
    column_spec(1, width = "0.2\\\\textwidth") |>
    column_spec(2, width = "0.2\\\\textwidth") |>
    column_spec(3, width = "0.6\\\\textwidth") |>
    row_spec(1:4, hline_after = TRUE)


## ----brushing, echo=FALSE, out.width="49%", fig.ncol=2, fig.show="hold", fig.cap="An illustration of the box selection and brush tool being used together."----
knitr::include_graphics(paste0("figures/implementation/pdfsense-brushing-", 1:4, ".png"))



## ----child="04-web-technologies.Rmd"------------------------------------------

## ----dataflow, fig.height=3, out.width=ifelse(knitr::is_html_output(), "100%", "\\textwidth"), fig.cap="An overview of the data flow when creating a detourr visualisation. The full tour path is generated in R and then passed to JavaScript when the widget is created. The operations that occur in the animation loop in JavaScript are the most important to optimise."----
library(grid)

## fill for text boxes
purple1 <- "#d6d5e7"
## arrows
purple2 <- "#c5c3dc"
# background
purple3 <- "#f7f7fa"

tbox <- function(txt, ...) {
    grid.roundrect(
        r = unit(2, "mm"), width = 0.7, height = 0.8,
        gp = gpar(col = NA, fill = purple1), ...
    )
    grid.text(txt, gp = gpar(fontsize = 12))
}

myarrow <- function(...) {
    grid.segments(...,
        arrow = arrow(type = "closed", length = unit(0.1, "inches")),
        gp = gpar(fill = purple2, col = purple2, lwd = 2)
    )
}

grid.newpage()

vp <- viewport(
    layout = grid.layout(3, 2,
        heights = c(0.33, 0.34, 0.33),
        widths = 0.5
    ), height = 0.9, y = 0, just = "bottom"
)

tl <- viewport(layout.pos.row = 1, layout.pos.col = 1, name = "topleft")
ml <- viewport(layout.pos.row = 2, layout.pos.col = 1, name = "middleleft")
bl <- viewport(layout.pos.row = 3, layout.pos.col = 1, name = "bottomleft")
tr <- viewport(layout.pos.row = 1, layout.pos.col = 2, name = "topright")
mr <- viewport(layout.pos.row = 2, layout.pos.col = 2, name = "middleright")
br <- viewport(layout.pos.row = 3, layout.pos.col = 2, name = "bottomright")

splot <- vpTree(vp, vpList(tl, ml, bl, tr, mr, br))

pushViewport(splot)
upViewport()

# background rects
grid.roundrect(
    r = unit(3, "mm"), width = 0.4, x = 0.05, just = "left",
    gp = gpar(col = NA, fill = purple3)
)
grid.roundrect(
    r = unit(3, "mm"), width = 0.4, x = 0.95, just = "right",
    gp = gpar(col = NA, fill = purple3)
)

# top
seekViewport("topleft")
tbox("Instantiate tour")

# middle
seekViewport("middleleft")
tbox("Generate tour path")
myarrow(
    x0 = 0.5, y0 = unit(1.1, "npc"),
    x1 = 0.5, y1 = unit(0.9, "npc")
)

# bottom
seekViewport("bottomleft")
tbox("Create and display widget", name = "tbox_bottomleft")
myarrow(
    x0 = 0.5, y0 = unit(1.1, "npc"),
    x1 = 0.5, y1 = unit(0.9, "npc")
)

seekViewport("topright")
tbox("Render points
(Three.js / WebGL)")

seekViewport("bottomright")
tbox("Calculate next frame Y=XA
(TensorFlow.js / WASM)")

seekViewport("middleright")

grid.text("Animation
loop")

grid.curve(0.4, 0, 0.4, 1,
    square = FALSE, curvature = -0.3, ncp = 10,
    arrow = arrow(
        type = "closed",
        length = unit(0.1, "inches")
    ),
    gp = gpar(fill = purple2, col = purple2, lwd = 2)
)


grid.curve(0.6, 1, 0.6, 0,
    square = FALSE, curvature = -0.3, ncp = 10,
    arrow = arrow(
        type = "closed",
        length = unit(0.1, "inches")
    ),
    gp = gpar(fill = purple2, col = purple2, lwd = 2)
)

popViewport()

myarrow(
    0.45, 1 / 6, 0.55, 1 / 6 #
)
grid.text("JSON", 0.5, unit(1 / 6, "npc") + unit(0.5, "lines"), just = "bottom")

popViewport()

grid.text("R", 0.25, unit(0.9, "npc") + unit(0.5, "lines"), just = "bottom")
grid.text("JavaScript", 0.75, unit(0.9, "npc") + unit(0.5, "lines"), just = "bottom")


## ----backend-comparison, echo=FALSE, out.width="75%", fig.align="center", fig.cap="Performance comparison across different data sets and backends. TensorFlow provides better performance than a hand-coded implementation across the board. For smaller datasets like pdfsense, there is little difference between CPU and WASM backends for TensorFlow.js, but for larger dataset WASM performs much better."----
benchmarks <- read_tsv("data/backend_benchmarks.tsv")

ggplot(benchmarks, aes(x = Backend, y = `Percent Time`, fill = `Data Set`)) +
    geom_col(position = "dodge") +
    theme_bw() +
    scale_y_continuous(labels = scales::label_number(suffix = "%")) +
    theme(
        legend.position = c(0.75, 0.75),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank()
    ) +
    labs(
        title = "TensorFlow Backend Performance Comparison",
        y = "% Scripting Time"
    )


## ----backend-comparison-slice, echo=FALSE, out.width="75%", fig.align="center", fig.cap="The additional matrix operations required by the slice tour display function make the performance benefit of the WASM backend much more apparent."----
benchmarks <- read_tsv("data/backend_benchmarks_slice.tsv")

ggplot(benchmarks, aes(x = Backend, y = `Percent Time`, fill = `Data Set`)) +
    geom_col(position = "dodge") +
    theme_bw() +
    scale_y_continuous(labels = scales::label_number(suffix = "%")) +
    theme(
        legend.position = c(0.75, 0.75),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank()
    ) +
    labs(
        title = "TensorFlow Backend Performance Comparison (slice tour)",
        y = "% Scripting Time"
    )



## ----child="05-display-methods.Rmd"-------------------------------------------

## ----echo=FALSE, eval=FALSE---------------------------------------------------
#> set.seed(1)
#> library(detourr)
#> library(tibble)
#> 
#> X <- geozoo::sphere.hollow(3, 2000)$points |>
#>     as_tibble()
#> 
#> detour(X, tour_aes(projection = everything())) |>
#>     tour_path(grand_tour(2)) |>
#>     show_slice(anchor = c(1, 0, 0))


## ----slice-sphere, out.width="32%", fig.ncol=3, fig.show="hold", fig.align="center", fig.cap="Selected frames of a 2D slice tour of a hollow unit sphere. The anchor for the slice is set to (1, 0, 0). Initially the slice is near the origin, but moves closer to the edge of the sphere as v1 rotates to be near orthogonal to the projection plane."----
knitr::include_graphics(c(
    "figures/display_methods/slice_sphere_1.png",
    "figures/display_methods/slice_sphere_2.png",
    "figures/display_methods/slice_sphere_3.png"
))


## ----eval=FALSE, echo=FALSE---------------------------------------------------
#> library(MASS)
#> # generate a random uniform sample within a unit p-ball
#> random_unif_pball <- function(n, p) {
#>     # multivariate normal has random direction, but not uniform radius
#>     df <- mvrnorm(n, rep(0, p), diag(rep(1, p)))
#> 
#>     # project points on to surface of unit ball
#>     df <- t(apply(df, 1, function(x) x / sqrt(sum(x^2))))
#> 
#>     # scale in to form a uniform distribution in the p-ball
#>     t(apply(df, 1, function(x) x * (runif(1)^(1 / p)))) |> as_tibble()
#> }
#> 
#> X <- random_unif_pball(500, 50)
#> p <- detour(X, tour_aes(projection = everything())) |>
#>     tour_path(grand_tour(3))
#> 
#> p |> show_scatter(axes = FALSE)
#> p |> show_sage(axes = FALSE)


## ----sage-sphere, out.width="32%", fig.ncol=3, fig.show="hold", fig.align="center", fig.cap="(Top) Initial frames of a 3D scatter tour of a 3, 10, and 50 dimensional ball respectively from left to right. (Bottom) Selected frames of a 3D sage tour of similar 3, 10, and 50 dimensional balls. As the dimensionality increases, the standard scatter display crowds the points near the center, whereas the sage display shows a consistent radial distribution of points. All screenshots are at the same zoom level."----
knitr::include_graphics(c(
    "figures/display_methods/scatter_sphere_3.png",
    "figures/display_methods/scatter_sphere_10.png",
    "figures/display_methods/scatter_sphere_50.png",
    "figures/display_methods/sage_sphere_3.png",
    "figures/display_methods/sage_sphere_10.png",
    "figures/display_methods/sage_sphere_50.png"
))



## ----child="06-case-study.Rmd"------------------------------------------------

## ----eval=FALSE---------------------------------------------------------------
#> set.seed(123)
#> library(detourr)
#> data(mnist_embeddings_8d)
#> detour(mnist_embeddings_8d, tour_aes(
#>     projection = starts_with("X"), color = label,
#>     label = c(id, label)
#> )) |>
#>     tour_path(grand_tour(2)) |>
#>     show_scatter()


## ----mnist-8d-scatter, out.width="49%", fig.ncol=2, fig.show="hold", fig.align="center", fig.cap="Selected frames from the 8-dimensional MNIST embeddings data using show\\_scatter() as the display method. The colour corresponds to the handwritten digit 0, 1, ..., 9. Despite the large number of data points, the animation of the tour is smooth and interactions are responsive."----
knitr::include_graphics(
    c(
        "figures/mnist/mnist-8d-scatter-1.png",
        "figures/mnist/mnist-8d-scatter-2.png",
        "figures/mnist/mnist-8d-scatter-label.png",
        "figures/mnist/mnist-8d-scatter-timeline.png"
    )
)


## ----eval=FALSE---------------------------------------------------------------
#> set.seed(123)
#> library(detourr)
#> data(mnist_embeddings_8d)
#> detour(mnist_embeddings_8d, tour_aes(
#>     projection = starts_with("X"), color = label,
#>     label = c(id, label)
#> )) |>
#>     tour_path(grand_tour(2)) |>
#>     show_sage()


## ----mnist-8d-sage, out.width="49%", fig.ncol=3, fig.show="hold", fig.align="center", fig.cap="Selected frames from the 8-dimensional MNIST embeddings data using show\\_sage() as the display method with a 2D grand tour path. The sage display shows the data points near the surface of the unit ball, which is due to the L2 normalisation of the original embeddings. This structure was not clear in the standard scatter display but is preserved with the sage display."----

knitr::include_graphics(
    c(
        "figures/mnist/mnist-8d-sage-1.png",
        "figures/mnist/mnist-8d-sage-2.png"
    )
)


## ----eval=FALSE---------------------------------------------------------------
#> set.seed(123)
#> library(detourr)
#> data(mnist_embeddings_8d)
#> detour(mnist_embeddings_32d, tour_aes(
#>     projection = starts_with("X"), color = label,
#>     label = c(id, label)
#> )) |>
#>     tour_path(grand_tour(3), fps = 5, aps = 0.2) |>
#>     show_slice(slice_relative_volume = 0.02)


## ----eval=FALSE---------------------------------------------------------------
#> set.seed(123)
#> library(detourr)
#> data(mnist_embeddings_8d)
#> detour(mnist_embeddings_8d, tour_aes(
#>     projection = starts_with("X"), color = label,
#>     label = c(id, label)
#> )) |>
#>     tour_path(grand_tour(2)) |>
#>     show_slice()


## ----mnist-8d-slice, out.width="49%", fig.ncol=3, fig.show="hold", fig.align="center", fig.cap="Selected frames of the 8-dimensional MNIST embeddings data using show\\_slice() as the display method. The slice display makes the hollowness of this data apparent."----
knitr::include_graphics(
    c(
        "figures/mnist/mnist-8d-slice-1.png",
        "figures/mnist/mnist-8d-slice-2.png"
    )
)


## ----linked-tsne-full, out.width=ifelse(knitr::is_html_output(), "100%", "\\textwidth"), fig.cap="Linked visuals of the tour using detourr (left) compared to a T-SNE dimension reduction (right)"----
knitr::include_graphics("figures/mnist/case-study-linked-brushing-full.png")


## ----linked-tsne-selection, out.width=ifelse(knitr::is_html_output(), "100%", "\\textwidth"), fig.cap="Linked visuals with selection applied. Points can be selected in either visual via click-and-drag and the selection will be reflected in both."----
knitr::include_graphics("figures/mnist/case-study-linked-brushing-selection.png")


## ----linked-tsne-filter, out.width=ifelse(knitr::is_html_output(), "100%", "\\textwidth"), fig.cap="Linked visuals with filtering applied. Viewing each digit individually makes outlying points much more apparent, and those points can be identified using tooltips."----
knitr::include_graphics("figures/mnist/case-study-linked-brushing-filter.png")


## ----eval=FALSE, echo=TRUE----------------------------------------------------
#> library(crosstalk)
#> library(Rtsne)
#> library(plotly)
#> 
#> data(mnist_embeddings_8d)
#> 
#> ts <- select(mnist_embeddings_8d, starts_with("X")) |>
#>     Rtsne(num_threads = 4)
#> Y <- as_tibble(ts$Y)
#> names(Y) <- c("Y1", "Y2")
#> 
#> plot_df <- bind_cols(mnist_embeddings_8d, Y)
#> shared_mnist <- SharedData$new(plot_df)
#> 
#> detour_plot <- detour(shared_mnist, tour_aes(
#>     projection = starts_with("X"), color = label,
#>     label = c(id, label),
#> )) |>
#>     tour_path(grand_tour(2)) |>
#>     show_sage(width = "100%", height = "450px")
#> 
#> tsne_plot <- plot_ly(shared_mnist,
#>     x = ~Y1,
#>     y = ~Y2,
#>     text = paste0("Label: ", plot_df$label, "<br>", "ID: ", plot_df$id),
#>     color = ~label,
#>     height = 450,
#>     colors = viridisLite::viridis(10)
#> ) |>
#>     highlight(on = "plotly_selected", off = "plotly_doubleclick") |>
#>     add_trace(type = "scatter", mode = "markers")
#> 
#> bscols(
#>     list(
#>         filter_checkbox("label", "Label", shared_mnist, ~label)
#>     ),
#>     detour_plot, tsne_plot,
#>     widths = c(1, 5, 6)
#> )



## ----child="07-future-work.Rmd"-----------------------------------------------




## ----child="A-appA.Rmd"-------------------------------------------------------

## -----------------------------------------------------------------------------
library(MASS)

F <- function(r, R = 1, p, d = 3) {
  pbeta((r / R)^2, d / 2, (p - d + 2) / 2)
}

get_sim_data <- function(p, d, n = 5000) {
  r_unif_pball <- mvrnorm(n, rep(0, p), diag(rep(1, p)))

  # project points on to surface of unit ball
  r_unif_pball <- t(apply(r_unif_pball, 1, function(x) x / sqrt(sum(x^2))))

  # scale in to form a uniform distibution in the p-ball
  r_unif_pball <- r_unif_pball * runif(n)^(1 / p)
  # rand_unif_p_ball <- t(apply(rand_unif_p_ball, 1, function(x) x * (1 - runif(1)^p)))

  r <- (1:n) / n
  proj <- r_unif_pball[, 1:d]
  radii_actual <- sqrt(rowSums(proj^2))
  F_emperical <- ecdf(radii_actual)(r)

  tibble(
    r = r,
    p = p,
    d = d,
    F_emperical = F_emperical,
    F_theoretical = F(r, p = p, d = d)
  )
}


## ----radial-cdf-p, fig.cap = "Relative projected volume for projections from p dimensions to d=3 dimensions. The solid line is simulated data, and the dashed line is the theoretical CDF", out.width="75%", fig.align="center"----
plot_data <- bind_rows(
  get_sim_data(p = 5, d = 3),
  get_sim_data(p = 10, d = 3),
  get_sim_data(p = 50, d = 3)
) |>
  mutate(p = as.character(p))
ggplot(plot_data, aes(x = r, group = p, colour = p)) +
  geom_line(aes(y = F_theoretical), lty = "dotdash") +
  geom_line(aes(y = F_emperical)) +
  theme_bw() +
  labs(
    title = "Radial projected CDF for a sphere",
    x = "r",
    y = "Relative projected volume"
  )


## ----radial-cdf-d, fig.cap = "Relative projected volume for a projection of p=10 dimensions to d dimensions.  The solid line is simulated data, and the dashed line is the theoretical CDF. This shows the generalisation to d > 3 dimensions", out.width="75%", fig.align="center"----
plot_data <- bind_rows(
  get_sim_data(p = 10, d = 2),
  get_sim_data(p = 10, d = 3),
  get_sim_data(p = 10, d = 4),
  get_sim_data(p = 10, d = 8)
) |>
  mutate(d = as.character(d))
ggplot(plot_data, aes(x = r, group = d, colour = d)) +
  geom_line(aes(y = F_theoretical), lty = "dotdash") +
  geom_line(aes(y = F_emperical)) +
  theme_bw() +
  labs(
    title = "Radial projected CDF for a ball with dimension d (p=10)",
    x = "r",
    y = "Relative projected volume"
  )


